---
title: "Statistical analyses"
output:
  
  html_document:
    theme: united
    df_print: paged
    toc: true
  html_notebook:
    theme: united
    toc: yes
---

```{r setup, echo=F}
library(knitr)
opts_chunk$set(warning = FALSE, root.dir = "/home/amira.azizan/Documents/Y320/GenDivDatabase")
```

```{r echo=T, message=F, include=T}
# Load packages
library(ggplot2)
library(dplyr)
library(lme4)
library(lmerTest)
options(na.action = na.omit)
```

## Load data

```{r}
load("Data/Popgenden.rda")
```

2 data sets are in the .rda file `gen_clus` for the cluster data set and `gen_country` for the country data set.

-   ref.gen format: FirstAuthor_FirstPublicationTitle_YearofPublication
-   ref.den format: FirstAuthor_JournalName_YearofPublication
-   average: AVE - only averaged GD available in the study, LOCUS - GD per locus is available and averaging the GD was done by Amira

1.  log10 transformed variables

```{r}
gen_clus$n.allele_log <- log10(gen_clus$n.allele)
gen_clus$sample.size_log <- log10(gen_clus$sample.size)
gen_clus$DP_log <- log10(gen_clus$DP_mean)
gen_clus$BS_log <- log10(gen_clus$BS)

gen_count$n.allele_log <- log10(gen_count$n.allele)
gen_count$sample.size_log <- log10(gen_count$sample.size)
gen_count$DP_log <- log10(gen_count$DP)
gen_count$BS_log <- log10(gen_count$BS)
```

2.  Plot the distribution of each variable

#### a)  Cluster data set {.tabset}

```{r, results='asis', echo=F}
for (i in 1:4) {
  j <- list(gen_clus$DP_log, gen_clus$ho, gen_clus$he, gen_clus$n.allele_log)[[i]]
  lab <- c("DP","Ho","He","Allelic richness")
  cat("##### ",lab[i],"\n")
  
  plot(density(j, na.rm=T), main="")
  
  
  cat(' \n \n')
}
```

#### b)  Country data set {.tabset}

```{r, results='asis', echo=F}
for (i in 1:4) {
  j <- list(gen_count$DP_log, gen_count$ho, gen_count$he, gen_count$n.allele_log)[[i]]
  lab <- c("DP","Ho","He","Allelic richness")
  cat("##### ",lab[i],"\n")

  plot(density(j, na.rm=T), main="")
  
  
  cat(' \n \n')
}
```

###



3.  Simple correlation test with sample size (mean number of individuals sampled for the GD estimates)

-   $H_o$ No correlation between GD and sample size size
-   $H_1$ GD increases with sample size

```{r}
# Pearson correlation coefficient
c1 <- cor.test(gen_clus$ho, log10(gen_clus$sample.size), method = "pearson", alt="g")[c("p.value","estimate")]
c2 <- cor.test(gen_clus$he, log10(gen_clus$sample.size), method = "pearson", alt="g")[c("p.value","estimate")] 
c3 <- cor.test(gen_clus$n.allele, log10(gen_clus$sample.size), method = "pearson", alt="g")[c("p.value","estimate")]
```

```{r, echo=F, results='asis'}
kable(rbind.data.frame(HoxSS=c1,HexSS=c2,ArxSS=c3))
```

All 3 GD estimates are correlated to sample size. Allelic richness has significantly high correlation, with r = `r as.numeric(c3$estimate)`

```{r eval=T, include=FALSE}
# add colors as in Fig1
no_green = c("#00007F", 
             "#0000B2", "#0000E5", "#0019FF", "#004DFF", "#007FFF", "#00B2FF", 
             "#00E5FF", "#7FFFFF", "#FFFFA5", "#FFFF54", 
             "#FFE500", "#FFB300", "#FF7F00", "#FF4C00", "#FF1900", 
             "#B20000", "#660000")


scales::show_col(no_green)
# reorder based on generation length
boo <- unique(gen_count[,c("sp","GenerationLength_d","BS")])
#boo <- boo[order(boo$GenerationLength_d),]
#gen_count$sp <- factor(gen_count$sp, levels = boo$sp)

no_green <- setNames(no_green, levels(gen_count$sp))
theme_set(theme_classic())

```


4.  Remove outliers in cluster dataset using the boxplot
Boxplots before outliers were removed
```{r, results='asis'}
par(mar=c(9,4,1,2))
boxplot(gen_clus$DP_log~gen_clus$sp,   xlab=NA, las=2, col=no_green[names(no_green) %in% unique(gen_clus$sp)], ylab="log10(PD)")
abline(h=mean(gen_clus$DP_log), lty=2)

boxplot(gen_clus$ho~gen_clus$sp, col=no_green[names(no_green) %in% unique(gen_clus$sp)] , xlab=NA,  las=2, ylab="Ho")
abline(h=mean(gen_clus$ho, na.rm=T), lty=2)

boxplot(gen_clus$he~gen_clus$sp, col=no_green[names(no_green) %in% unique(gen_clus$sp)], las=2, xlab=NA,  ylab="He",)
abline(h=mean(gen_clus$he, na.rm=T), lty=2)

boxplot(log10(gen_clus$n.allele)~gen_clus$sp, col=no_green[names(no_green) %in% unique(gen_clus$sp)], las=2, xlab=NA,cex=1,  ylab="log10(n.allele)")
abline(h=mean(log10(gen_clus$n.allele), na.rm=T), lty=2)

```



```{r include=TRUE}
Ho <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_clus$sp)){
   felsil <- subset(gen_clus, sp %in% j)
   x = felsil$ho
   if (all(is.na(x))) next
   out <- boxplot(x, plot=FALSE)$out
   a1 <- felsil[x %in% out,]
   if (length(out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   Ho <- rbind(Ho, a2)
}

He <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_clus$sp)){
   felsil <- subset(gen_clus, sp %in% j)
   x = felsil$he
   if (all(is.na(x))) next
   Ar_out <- boxplot(x, plot=FALSE)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   He <- rbind(He, a2)
}


Ar <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_clus$sp)){
   felsil <- subset(gen_clus, sp %in% j)
   x = log10(felsil$n.allele)
   if (all(is.na(x))) next
   Ar_out <- boxplot(x, plot=FALSE)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   Ar <- rbind(Ar, a2)
}

Dp <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_clus$sp)){
   felsil <- subset(gen_clus, sp %in% j)
   x = log10(felsil$DP_mean)
   if (all(is.na(x))) next
   Ar_out <- boxplot(x, plot=FALSE)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   Dp <- rbind(Dp, a2)
}

# tagg outliers
gen_clus$ho_out <- FALSE
gen_clus$ho_out[rownames(gen_clus) %in% Ho$rownames] <- TRUE

gen_clus$he_out <- FALSE
gen_clus$he_out[rownames(gen_clus) %in% He$rownames] <- TRUE

gen_clus$ar_out <- FALSE
gen_clus$ar_out[rownames(gen_clus) %in% Ar$rownames] <- TRUE

gen_clus$dp_out <- FALSE
gen_clus$dp_out[rownames(gen_clus) %in% Dp$rownames] <- TRUE

gen_clus[which(gen_clus$DP_log %in% boxplot(gen_clus$DP_log, plot=F)$out),"dp_out"] <- TRUE
```

Boxplots after outliers were removed

```{r, results='asis', echo=F}
par(mar=c(9,4,1,2))
boxplot(gen_clus$DP_log[!gen_clus$dp_out]~gen_clus$sp[!gen_clus$dp_out],  las=2,, xlab=NA,  ylab="log10(PD)")
boxplot(gen_clus$ho[!gen_clus$ho_out]~gen_clus$sp[!gen_clus$ho_out],  las=2, xlab=NA,  ylab="Ho")
boxplot(gen_clus$he[!gen_clus$he_out]~gen_clus$sp[!gen_clus$he_out], las=2, xlab=NA,  ylab="He", las=2,)
boxplot(log10(gen_clus$n.allele[!gen_clus$ar_out])~gen_clus$sp[!gen_clus$ar_out], las=2, xlab=NA,cex=1,  ylab="log10(n.allele)")

```

Do the same for the country data set

```{r, include=F}
Ho <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_count$sp)){
   felsil <- subset(gen_count, sp %in% j)
   x = felsil$ho
   if (all(is.na(x))) next
   Ar_out <- boxplot(x,plot=F)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   Ho <- rbind(Ho, a2)
}

He <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_count$sp)){
   felsil <- subset(gen_count, sp %in% j)
   x = felsil$he
   if (all(is.na(x))) next
   Ar_out <- boxplot(x, plot=F)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   He <- rbind(He, a2)
}


Ar <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_count$sp)){
   felsil <- subset(gen_count, sp %in% j)
   x = log10(felsil$n.allele)
   if (all(is.na(x))) next
   Ar_out <- boxplot(x, plot=F)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   Ar <- rbind(Ar, a2)
}

Dp <- data.frame(sp=character(), rownames=numeric())

for (j in unique(gen_count$sp)){
   felsil <- subset(gen_count, sp %in% j)
   x = log10(felsil$DP)
   if (all(is.na(x))) next
   Ar_out <- boxplot(x, plot=F)$out
   a1 <- felsil[x %in% Ar_out,]
   if (length(Ar_out) == 0) next
   a2 <- data.frame(sp=j, rownames=rownames(a1))
   Dp <- rbind(Dp, a2)
}

# tagg as outliers
gen_count$ho_out <- FALSE
gen_count$ho_out[rownames(gen_count) %in% Ho$rownames] <- TRUE

gen_count$he_out <- FALSE
gen_count$he_out[rownames(gen_count) %in% He$rownames] <- TRUE

gen_count$ar_out <- FALSE
gen_count$ar_out[rownames(gen_count) %in% Ar$rownames] <- TRUE

gen_count$dp_out <- FALSE
gen_count$dp_out[rownames(gen_count) %in% Dp$rownames] <- TRUE

gen_count[which(gen_count$DP_log %in% boxplot(gen_count$DP_log, plot=F)$out),"dp_out"] <- TRUE
 ###
```


## GD and DP Relationship within species

```{r, echo=F}
kable(sort(table(gen_clus$sp)), caption="Number of clusters in each species (from lowest to highest)")
j <- names(sort(table(gen_clus$sp), TRUE)[1:6])
sp_clus <- subset(gen_clus, sp %in% j)
sp_clus <- droplevels(sp_clus)
sp_clus$sp <- factor(sp_clus$sp, levels=j)
```


```{r, eval=T, include=F}
gen_clus$population.gen <- gsub("Nature Reserve", "NR", gen_clus$population.gen)
gen_clus$population.gen <- gsub("NR- ", "NR and \n", gen_clus$population.gen)
ponca <- gen_clus[which(gen_clus$sp == "Panthera onca"),]
ptigr <- gen_clus[which(gen_clus$sp == "Panthera tigris"),]
pum <- gen_clus[which(gen_clus$sp == "Puma concolor"),]
pleo <- gen_clus[which(gen_clus$sp == "Panthera leo"),]
ppar <- gen_clus[which(gen_clus$sp == "Panthera pardus"),]



df_sp <- list(ppar, ptigr, ponca, pleo, pum)
lab <- c("a) Panthera pardus","b) Panthera tigris", "c) Panthera onca", "d) Panthera leo", "e) Puma concolor")
plot_sp <- list()

# Function to use boxplot.stats to set the box-and-whisker locations  
f.bxp = function(x) {
  bxp = boxplot.stats(x)[["stats"]]
  names(bxp) = c("ymin","lower", "middle","upper","ymax")
  bxp
}  

# Function to use boxplot.stats for the outliers
f.out = function(x) {
  data.frame(y=boxplot.stats(x)[["out"]])
}

library(ggpubr)
library(ggrepel)
i = 2
for (i in 1:length(df_sp)){
  df <- df_sp[[i]]
  
  dp_out <- df$DP_log %in% boxplot(df$DP_log, plot=F)$out
  Ho_out <- df$ho %in% boxplot(df$ho, plot=F)$out 

  p_Ho <- ggscatter(df, x = "DP_log", y = "ho",  xlab="log10(PD)", main="",
              #  add = "reg.line",  # Add regressin line
               # add.params = list(color = "black", linecolor = "black"), # Customize reg. line
                conf.int = F # Add confidence interval
) + stat_cor(method = "p", alternative = "greater", color="black", size=5,digits=2,  label.y=1, aes(
               label =paste(..r.label.., ..p.label.., cut(..p.., 
                                              breaks = c(-Inf, 0.0001, 0.001, 0.01, 0.05, Inf),
                                              labels = c("'****'", "'***'", "'**'", "'*'", "''")), 
                            sep = "~")), 
           ) + ylim(c(0,1)) + ylab("Ho")
    

p_Ho


  # add outliers
if (any(Ho_out) | any(dp_out)){
  df_out <- df[!Ho_out & !dp_out,]
  
  
  p_Ho <- p_Ho + 
  geom_point(data=df[Ho_out,], aes(x=DP_log, y=ho), col="red") + 
  geom_text_repel(data = df[Ho_out,], aes(label=population.gen), inherit.aes=T, box.padding = 0) +
  geom_point(data=df[dp_out,], aes(x=DP_log, y=ho), col="green") + 
  geom_text_repel(data = df[dp_out,], aes(label=population.den), inherit.aes=T, box.padding = 0) +
  #geom_smooth(data=df[!Ho_out,], aes(x=DP_log, y=ho), se=F, method="lm", col="blue", linetype="dashed") + 
  stat_cor(data=df_out, aes(x=DP_log, y=ho,       label =paste(..r.label.., ..p.label.., cut(..p.., 
                                              breaks = c(-Inf, 0.0001, 0.001, 0.01, 0.05, Inf),
                                              labels = c("'****'", "'***'", "'**'", "'*'", "''")), 
                            sep = "~")), method = "p", alternative = "greater", label.y=0.92, color="blue", size=5, digits=2,)
}
p_Ho

ybp <- ggboxplot(df$ho, width = 1, col="black", fill = "transparent",outlier.shape = 1) +
  theme_transparent()
ybp_grob <- ggplotGrob(ybp)

xmin <- min(df$DP_log); xmax <- max(df$DP_log)
xoffset = 0.2
ymin <- min(df$ho, na.rm=T); ymax <- max(df$ho, na.rm=T)

p_Ho <- p_Ho  + xlim(c(xmin, xmax+xoffset)) +  annotation_custom(grob = ybp_grob, xmin = xmax, ymin = ymin-0.05, ymax = ymax+0.05)

#
He_out <- df$he %in% boxplot(df$he, plot=F)$out 

p_He <- ggscatter(df, x = "DP_log", y = "he",  xlab="log10(PD)", main="",
                 # add = "reg.line",  # Add regressin line
                #  add.params = list(color = "black"), # Customize reg. line
                  conf.int = F # Add confidence interval
) + stat_cor(method = "p", alternative = "greater", color="black", size=5, label.y=1, digits=2,aes(
               label =paste(..r.label.., ..p.label.., cut(..p.., 
                                              breaks = c(-Inf, 0.0001, 0.001, 0.01, 0.05, Inf),
                                              labels = c("'****'", "'***'", "'**'", "'*'", "''")), 
                            sep = "~")), 
           ) + ylim(c(0,1)) + ylab("He")
if (any(He_out) | any(dp_out)){
  df_out <- df[!He_out & !dp_out,]
  
p_He <- p_He + 
  geom_point(data=df[He_out,], aes(x=DP_log, y=he), col="red") + 
  geom_text_repel(data = df[He_out,], aes(label=population.gen), inherit.aes=T, box.padding = 0) +
  geom_point(data=df[dp_out,], aes(x=DP_log, y=he), col="green") + 
  geom_text_repel(data = df[dp_out,], aes(label=population.den), inherit.aes=T, box.padding = 0) +
  #geom_smooth(data=df[!He_out,], aes(x=DP_log, y=he), se=F, method="lm", col="blue", linetype="dashed") + 
  stat_cor(data=df[!He_out,], aes(x=DP_log, y=he,       label =paste(..r.label.., ..p.label.., cut(..p.., 
                                              breaks = c(-Inf, 0.0001, 0.001, 0.01, 0.05, Inf),
                                              labels = c("'****'", "'***'", "'**'", "'*'", "''")), 
                            sep = "~")), method = "p", alternative = "greater", label.y=0.92, color="blue", size=5, digits=2,)
}

# p_He <- p_He + geom_point(data = df[rownames(df) %in% ext,], inherit.aes=T, col="red") + 
#   geom_text_repel(data = df[rownames(df) %in% ext,], aes(label=population), inherit.aes=T, box.padding = 0) +
#   geom_smooth(data = df, inherit.aes=T, method="lm", col="lightgray", linetype="dashed", se=F)


ybp <- ggplot(df, aes(x=0, y=he)) + 
  stat_summary(fun.data=f.bxp, geom="boxplot") + 
  stat_summary(fun.data=f.out, geom="point", shape=1) +
  theme_transparent()

ybp_grob <- ggplotGrob(ybp)

xmin <- min(df$DP_log); xmax <- max(df$DP_log)
xoffset = 0.2
ymin <- min(df$he, na.rm=T); ymax <- max(df$he, na.rm=T)
yoffset <- (1/15)*ymax
p_He <- p_He + xlim(c(xmin, xmax+xoffset)) + annotation_custom(grob = ybp_grob, xmin = xmax, ymin = ymin-0.05, ymax = ymax+0.05)

p_He                                                               
#

df$n.allele_log <- log10(df$n.allele)
ar_out <- df$n.allele_log %in% boxplot(df$n.allele_log, plot=F)$out 

p_mna <- ggscatter(df, x = "DP_log", y = "n.allele_log", ylab="log10(Ar)", xlab="log10(PD)", main="",
                   #add = "reg",  # Add regressin line
                   #add.params = list(color = "black"), # Customize reg. line
                   conf.int = F # Add confidence interval
) + stat_cor(method = "p", alternative = "greater", label.y=1.3, col="black",  size=5,digits=2,
             aes(label =paste(..r.label.., ..p.label.., cut(..p.., 
                                              breaks = c(-Inf, 0.0001, 0.001, 0.01, 0.05, Inf),
                                              labels = c("'****'", "'***'", "'**'", "'*'", "''")), 
                            sep = "~")))+ ylim(c(0,1.3))




if (any(ar_out) | any(dp_out)){
  df_out <- df[!ar_out & !dp_out,]
  
p_mna <- p_mna + 
  geom_point(data=df[ar_out,], aes(x=DP_log, y=n.allele_log), col="red") + 
  geom_text_repel(data = df[ar_out,], aes(label=population.gen), inherit.aes=T, box.padding = 0) +
  geom_point(data=df[dp_out,], aes(x=DP_log, y=n.allele_log), col="green") + 
  geom_text_repel(data = df[dp_out,], aes(label=population.den), inherit.aes=T, box.padding = 0) +
  #geom_smooth(data=df[!ar_out,], aes(x=DP_log, y=n.allele_log), se=F, method="lm", col="blue", linetype="dashed") + 
  stat_cor(data=df[!ar_out,], aes(x=DP_log, y=n.allele_log, label =paste(..r.label.., ..p.label.., cut(..p.., 
                                              breaks = c(-Inf, 0.0001, 0.001, 0.01, 0.05, Inf),
                                              labels = c("'****'", "'***'", "'**'", "'*'", "''")), 
                            sep = "~")), method = "p", alternative = "greater", label.y=1.2, color="blue", size=5, digits=2)
}




# p_mna <- p_mna + geom_point(data = df[rownames(df) %in% ext,], inherit.aes=T, col="red") + 
#   geom_text_repel(data = df[rownames(df) %in% ext,], aes(label=population), inherit.aes=T) +
#   geom_smooth(data = df, inherit.aes=T, method="lm", col="lightgray", linetype="dashed", se=F) 


xbp <- ggboxplot(df$DP_log, width = 0.5, color="black", fill = "transparent", outlier.shape = 1) +
  ggpubr::rotate() +
  theme_transparent()

ybp <- ggplot(df, aes(x=0, y=n.allele_log)) + 
  stat_summary(fun.data=f.bxp, geom="boxplot") + 
  stat_summary(fun.data=f.out, geom="point", shape=1) +
  theme_transparent()

ybp_grob <- ggplotGrob(ybp)
xbp_grob <- ggplotGrob(xbp)
xmin <- min(df$DP_log); xmax <- max(df$DP_log)
xoffset = 1/10*xmax

ymin <- min(df$n.allele_log, na.rm=T); ymax <- max(df$n.allele_log, na.rm=T)
yoffset = 1/10*ymax
  
p_mna <- p_mna + xlim(c(xmin, xmax+xoffset))+  
  annotation_custom(grob = ybp_grob,xmin = xmax,   ymin = ymin-yoffset, ymax = ymax+yoffset) + 
  annotation_custom(grob = xbp_grob, xmin = xmin-xoffset, xmax = xmax, ymax = ymin)


plot_sp[[i]] <- ggarrange(p_Ho, p_He, p_mna, ncol=3, nrow=1, labels=lab[i], font.label = list(size = 14, color = "black", face = "italic"))
}
```

#### GD and PD relationship in 5 species with the most number of clusters {.tabset}

```{r, echo=F, fig.width=10, fig.height=5, results='asis'}
for (i in 1:length(plot_sp)) {
  cat("##### ",lab[i],"\n")
  print(plot_sp[[i]])
  
  cat(' \n \n')
}

```

###


Red points represent the outliers in the GD data whereas green points are the outliers in the PD data.




## Preliminary analyses

```{r, include=F}
#add label for figures
gen_clus$label <- paste0("atop(italic(",substr(gen_clus$genus, start = 1, stop = 1),".", 
                         gsub(".*. ", "", gen_clus$sp),"),", 
                         gsub(" ", "~", trimws(gen_clus$population.gen)),")")

```

-   Using mean estimates per species

```{r}
clus.mean <- gen_clus %>% group_by(sp) %>% summarise(
  ho = mean(ho, na.rm=T),
  he = mean(he, na.rm=T),
  n.allele = mean(n.allele, na.rm=T),
  dp = mean(DP_mean, na.rm=T),
  
)

m1 <- lm(ho ~ log10(dp), data= clus.mean)
summary(m1)
m2 <- lm(he ~ log10(dp), data= clus.mean)
summary(m2)
m3 <- lm(log10(n.allele) ~ log10(dp), data= clus.mean)
summary(m3)
```

PD effect is nonsignificant when using mean estimates per species

-   Using mean estimates per cluster

```{r}

clus.mean.1 <- gen_clus %>% group_by(sp, cluster_center) %>% summarise(
  ho = mean(ho, na.rm=T),
  he = mean(he, na.rm=T),
  n.allele = mean(n.allele, na.rm=T),
  dp = mean(DP_mean, na.rm=T),
  
)

m1 <- lm(ho ~ log10(dp) + sp, data= clus.mean.1)
summary(m1)
anova(m1)
m2 <- lm(he ~ log10(dp) + sp, data= clus.mean.1)
summary(m2)
anova(m2)
m3 <- lm(log10(n.allele) ~ log10(dp) + sp, data= clus.mean.1)
summary(m3)
anova(m3)
```

Species effect is significant when using the estimated mean response variable per cluster

## Modeling the relationship between GD and PD

### Simple LME models (no covariates)

1.  cluster dataset

-   Ho

```{r include=TRUE}
library(lmerTest)
df_Ho <- subset(gen_clus, !is.na(ho) & ho < 1)

Ho.lmer <- lmer(ho ~ DP_log + (1|sp), data = df_Ho[!df_Ho$ho_out & !df_Ho$dp_out,],  REML=F) 
summary(Ho.lmer)
```

-   He

```{r include=TRUE}
df_He <- subset(gen_clus, !is.na(he) & he < 1 & he > 0)
He.lmer <- lmer(he ~ DP_log + (1|sp), data = df_He[!df_He$he_out & !df_He$dp_out,], REML=F)
summary(He.lmer)
```

-   allelic richness

```{r include=TRUE}
#log transform n.allele to meet the normality of error term assumptions
gen_clus$n.allele_log <- log10(gen_clus$n.allele)

df_mna <- subset(gen_clus, !is.na(n.allele))
mna.lmer <- lmer(n.allele_log ~ DP_log + (1|sp), data = df_mna[!df_mna$ar_out & !df_mna$dp_out,], REML=FALSE)
summary(mna.lmer)
```

2.  Country dataset

-   Ho

```{r include=TRUE}
df_Ho.c <- subset(gen_count, !is.na(ho) & ho < 1)

Ho.c.lmer <- lmer(ho ~ DP_log + (1|sp), data = df_Ho.c[!df_Ho.c$ho_out & !df_Ho.c$dp_out,],  REML=F) 
summary(Ho.c.lmer)
```

-   He

```{r include=TRUE}
df_He.c <- subset(gen_count, !is.na(he) & he < 1 & he > 0)
He.c.lmer <- lmer(he ~ DP_log + (1|sp), data = df_He.c[!df_He.c$he_out & !df_He.c$dp_out,], REML=F)
summary(He.c.lmer)
```

-   allelic richness

```{r include=TRUE}
#log transform n.allele to meet the normality of error term assumptions
gen_count$n.allele_log <- log10(gen_count$n.allele)
df_mna.c <- subset(gen_count, !is.na(n.allele))
mna.c.lmer <- lmer(n.allele_log ~ DP_log + (1|sp), data = df_mna.c[!df_mna.c$ar_out & !df_mna.c$dp_out,], REML=FALSE)
summary(mna.c.lmer)
```

All 3 GD models showed significant effect of PD

```{r, eval=F, include=F}
#Plot figure 2
#source("~/Documents/Y320/GenDivDatabase/Rscript/StatisticalAnalyses_PlotPred.R")
```

## Includes covariates 

1.  Cluster final models

-   **Ho**

```{r eval=TRUE}
library(MuMIn)
library(performance)


df <- df_Ho[!df_Ho$ho_out & !df_Ho$dp_out,]
df$GL  <- df$GenerationLength_d
```

scale all covariates to have mean = 0 and standard deviation = 1

```{r eval=TRUE}
df <- df %>% mutate_at(c("DP_log","GL","BS_log","sample.size_log"), ~(scale(.) %>% as.vector))
```

using step-wise approach that is by adding more factor, from highest to lowest effect size

```{r eval=TRUE}
for (i in 1:4) {
  var <- c("DP_log","GL","BS_log","sample.size_log")
  print(fixef(lmer(paste("ho ~", var[i], "+ (1|sp)"), data=df))[2])
  
}

```

```{r eval=TRUE}
null_Ho <- lmer(ho ~ 1 + (1|sp), data = df, REML = F)
full_Ho <- update(null_Ho, . ~ . + GL)
full_Ho_1 <- update(full_Ho, . ~ . + DP_log)
full_Ho_2 <- update(full_Ho_1, . ~ . + BS_log)
full_Ho_3 <- update(full_Ho_2, . ~ . + sample.size_log)
compare_performance(null_Ho, full_Ho, full_Ho_1, full_Ho_2, full_Ho_3, rank = TRUE)

options(na.action = na.fail)
dr_Ho <- dredge(full_Ho_3, fixed=~(1|sp), 
                rank = "AIC", extra = list("R2M" = function(x) {r.squaredGLMM(x)[1]}, "R2C" = function(x) r.squaredGLMM(x)[2], "var. sp" = function(x) as.numeric(insight::get_variance_random(x))))

# Set as data.frame
dredge2df <- function(dr){
   dr.df <- as.data.frame(dr)
   dr.df$Model <- rownames(dr.df)
   for(i in 1:nrow(dr.df)) {
     form <- formula(paste(attr(dr,"model.calls")[[i]])[2])
     
     dr.df$Model[i] <- as.character(form)[3]
   }
   dr.df$Model <- gsub(" \\+ \\(1 \\| sp\\)", "", dr.df$Model)
   
   dr.df <- dr.df[,c(ncol(dr.df),1:ncol(dr.df)-1)]
   dr.df
}

dr_Ho.df <- dredge2df(dr=dr_Ho)
```

```{r, results='asis', echo=F}
kable(dr_Ho.df, digits=2)
```

Model selection - most parsimonious that is the one with the least AIC

```{r best_Ho, eval=TRUE, include=T}
best_Ho <- lmer(formula=formula(attr(dr_Ho[1], "model.calls")[[1]]), df)
summary(best_Ho)
```

Remove outliers; thoses with low PD but high GD

```{r eval=TRUE, include=T}
foo <- df[df$DP_log %in% head(sort(df$DP_log),5),]
foo[order(foo$DP_log),]

best_Ho.1 <- update(best_Ho, data=df[!rownames(df) %in% c(204,159,169),])
broom.mixed::tidy(best_Ho.1)
```

Remove lion data, to verify whether the methods to estimate PD can influence the relationship

```{r eval=TRUE, include=T}
summary(update(best_Ho, data=df[which(df$sp != "Panthera leo"),]))
# No differences
```

-   **He**

```{r eval=TRUE, include=FALSE}
df <- df_He[!df_He$he_out & !df_He$dp_out,]
df$GL  <- df$GenerationLength_d
#scale all covariates to have mean = 0 and standard deviation = 1
df <- df %>% mutate_at(c("DP_log","GL","BS_log","sample.size_log"), ~(scale(.) %>% as.vector))
```


```{r eval=TRUE}
for (i in 1:4) {
  var <- c("DP_log","GL","BS_log","sample.size_log")
  print(fixef(lmer(paste("he ~", var[i], "+ (1|sp)"), data=df ))[2])
  
}
```

```{r Mod_He_clus, eval=TRUE, include=T}
null_He <- lmer(he ~ 1 + (1|sp), data = df, REML = F)
full_He <- update(null_He, . ~ . +  GL)
full_He_1 <- update(full_He, . ~ . + sample.size_log)
full_He_2 <- update(full_He_1, . ~ . + DP_log)
full_He_3 <- update(full_He_2, . ~ . + BS_log)

compare_performance(null_He, full_He, full_He_1, full_He_2, full_He_3, rank = T)

dr_He <- dredge(full_He_3, fixed=~(1|sp), 
                rank = "AIC", extra = list("R2M" = function(x) {r.squaredGLMM(x)[1]}, "R2C" = function(x) r.squaredGLMM(x)[2], "var. sp" = function(x) as.numeric(insight::get_variance_random(x))))


dr_He.df <- dredge2df(dr=dr_He)
```

```{r, results='asis', echo=F}
kable(dr_He.df, digits=2)
```

```{r best_He, eval=TRUE, include=T}
best_He <- lmer(formula=formula(attr(dr_He[1], "model.calls")[[1]]), df)
summary(best_He)

#remove outliers
foo <- df[df$DP_log %in% head(sort(df$DP_log),5),]
foo[order(foo$DP_log),]

best_He.1 <- update(best_He, data=df[!rownames(df) %in% c(159,169,204),])
broom.mixed::tidy(best_He.1)
```

-   **Allelic richness**

```{r eval=TRUE, include=FALSE}
###
df <- df_mna[!df_mna$ar_out & !df_mna$dp_out,]
df$GL  <- df$GenerationLength_d
#scale all covariates to have mean = 0 and standard deviation = 1
df <- df %>% mutate_at(c("DP_log","GL","BS_log","sample.size_log"), ~(scale(.) %>% as.vector))
for (i in 1:4) {
  var <- c("DP_log","GL","BS_log","sample.size_log")
  print(fixef(lmer(paste("log10(n.allele) ~", var[i], "+ (1|sp)"), data=df))[2])
  
}
```

```{r Mod_Ar_clus}
## MNA model : need to add ref as random effect to meet the linearity of the residuals assumption
null_mna <- lmer(n.allele_log ~ 1 + (1|sp), data = df, REML=F)
full_mna <- update(null_mna, . ~ . + sample.size_log, REML=F)
full_mna_1 <- update(full_mna, . ~ . + GL)
full_mna_2 <- update(full_mna_1, . ~. + DP_log)
full_mna_3 <- update(full_mna_2, . ~. + BS_log)
compare_performance(null_mna, full_mna, full_mna_1, full_mna_2, full_mna_3, rank = T)

dr_mna <- dredge(full_mna_3, fixed=~(1|sp), rank = "AIC", extra = list("R2M" = function(x) {r.squaredGLMM(x)[1]}, "R2C" = function(x) r.squaredGLMM(x)[2], "var. sp" = function(x) as.numeric(insight::get_variance_random(x))))

dr_mna.df <- dredge2df(dr_mna)

```

```{r, results='asis', echo=F}
kable(dr_mna.df, digits=2)
```

```{r best_mna, eval=TRUE, include=FALSE}
best_mna <- lmer(formula=formula(attr(dr_mna[1], "model.calls")[[1]]), df)
summary(best_mna)

#remove outliers
foo <- df[df$DP_log %in% head(sort(df$DP_log),5),]
foo[order(foo$DP_log),]
```


```{r eval=TRUE, include=FALSE}
best_mna.1 <- update(best_mna, data=df[!rownames(df) %in% c(159,204),])
broom.mixed::tidy(best_mna.1)

```

check the assumption of equal variances (homoscedasticity)

```{r eval=FALSE, include=T}
## Best-fit models
plot(best_Ho)
plot(best_He)
plot(best_mna)
```

2.  Country final models

```{r eval=TRUE, include=T}
df <- df_Ho.c[!df_Ho.c$ho_out & !df_Ho.c$dp_out,]
df$GL  <- df$GenerationLength_d
```

scale all covariates to have mean = 0 and standard deviation = 1

```{r eval=TRUE, include=T}
df <- df %>% mutate_at(c("DP_log","GL","BS_log","sample.size_log"), ~(scale(.) %>% as.vector))
for (i in 1:4) {
  var <- c("DP_log","GL","BS_log","sample.size_log")
  print(fixef(lmer(paste("ho ~", var[i], "+ (1|sp)"), data=df ))[2])
  
}
```

-   Ho

```{r eval=TRUE, include=T}
null_Ho <- lmer(ho ~ 1 + (1|sp), data = df, REML = F)
full_Ho <- update(null_Ho, . ~ . + GL)
full_Ho_1 <- update(full_Ho, . ~ . + DP_log)
full_Ho_2 <- update(full_Ho_1, . ~ . + BS_log)
full_Ho_3 <- update(full_Ho_2, . ~ . + sample.size_log)

compare_performance(null_Ho, full_Ho, full_Ho_1, full_Ho_2, full_Ho_3, rank = TRUE)

options(na.action = na.fail)
dr_Ho <- dredge(full_Ho_3, fixed=~(1|sp), 
                rank = "AIC", extra = list("R2M" = function(x) {r.squaredGLMM(x)[1]}, "R2C" = function(x) r.squaredGLMM(x)[2], "var. sp" = function(x) as.numeric(insight::get_variance_random(x))))


# Set as data.frame

dr_Ho.df.c <- dredge2df(dr=dr_Ho)
```

```{r, results='asis', echo=F}
kable(dr_Ho.df.c, digits=2)
```

```{r eval=TRUE, echo=FALSE}
best_Ho.c <- lmer(formula=formula(attr(dr_Ho[1], "model.calls")[[1]]), df)
summary(best_Ho.c)
```

```{r}
#include outliers
df_Ho.c$GL <- df_Ho.c$GenerationLength_d
best_Ho.c1 <- update(best_Ho.c, data=df_Ho.c) 
summary(best_Ho.c1)
##
```

-   He

```{r eval=TRUE, include=FALSE}
df <- df_He.c[!df_He.c$he_out & !df_He.c$dp_out,]
df$GL  <- df$GenerationLength_d
#scale all covariates to have mean = 0 and standard deviation = 1
df <- df %>% mutate_at(c("DP_log","GL","BS_log","sample.size_log"), ~(scale(.) %>% as.vector))
```

```{r}
for (i in 1:4) {
  var <- c("DP_log","GL","BS_log","sample.size_log")
  print(fixef(lmer(paste("he ~", var[i], "+ (1|sp)"), data=df ))[2])
  
}
```

```{r eval=TRUE, include=FALSE}
null_He <- lmer(he ~ 1 + (1|sp), data = df, REML = F)
full_He <- update(null_He, . ~ . +  GL)
full_He_1 <- update(full_He, . ~ . + DP_log)
full_He_2 <- update(full_He_1, . ~ . + sample.size_log)
full_He_3 <- update(full_He_2, . ~ . + BS_log)

compare_performance(null_He, full_He, full_He_1, full_He_2, full_He_3, rank = T)


dr_He <- dredge(full_He_3, fixed=~(1|sp), 
                rank = "AIC", extra = list("R2M" = function(x) {r.squaredGLMM(x)[1]}, "R2C" = function(x) r.squaredGLMM(x)[2], "var. sp" = function(x) as.numeric(insight::get_variance_random(x))))


dr_He.df.c <- dredge2df(dr=dr_He)
```

```{r, results='asis', echo=F}
kable(dr_He.df.c, digits=2)
```

```{r eval=TRUE, echo=FALSE}
best_He.c <- lmer(formula=formula(attr(dr_He[1], "model.calls")[[1]]), df)
summary(best_He.c)
```

```{r eval=TRUE, echo=FALSE}
df_He.c$GL <- df_He.c$GenerationLength_d
# Include outliers
best_He.c1 <- update(best_He.c, data=df_He.c)
# exclude lion data
summary(update(best_He.c, data=df_He.c[-which(df_He.c$sp == "Panthera leo"),]))

###
```

-   AR

```{r eval=TRUE, include=FALSE}
df <- df_mna.c[!df_mna.c$ar_out & !df_mna.c$dp_out,]
df$GL  <- df$GenerationLength_d
#scale all covariates to have mean = 0 and standard deviation = 1
df <- df %>% mutate_at(c("DP_log","GL","BS_log","sample.size_log"), ~(scale(.) %>% as.vector))
```

```{r eval=TRUE}
for (i in 1:4) {
  var <- c("DP_log","GL","BS_log","sample.size_log")
  print(fixef(lmer(paste("log10(n.allele) ~", var[i], "+ (1|sp)"), data=df))[2])
  
}
```

```{r eval=TRUE, include=FALSE}
## MNA model
null_mna <- lmer(n.allele_log ~ 1 + (1|sp), data = df, REML=F)
full_mna <- update(null_mna, . ~ . + GL, REML=F)
full_mna_1 <- update(full_mna, . ~ . + sample.size_log)
full_mna_2 <- update(full_mna_1, . ~. + DP_log)
full_mna_3 <- update(full_mna_2, . ~. + BS_log)
compare_performance(null_mna, full_mna, full_mna_1, full_mna_2, full_mna_3, rank = T)

dr_mna <- dredge(full_mna_3, fixed=~(1|sp), rank = "AIC", extra = list("R2M" = function(x) {r.squaredGLMM(x)[1]}, "R2C" = function(x) r.squaredGLMM(x)[2], "var. sp" = function(x) as.numeric(insight::get_variance_random(x))))
dr_mna.df.c <- dredge2df(dr_mna)

```

```{r, results='asis', echo=F}
kable(dr_mna.df.c, digits=2)
```

```{r eval=TRUE, echo=FALSE}
best_mna.c <- lmer(formula=formula(attr(dr_mna[1], "model.calls")[[1]]), df)
summary(best_mna.c)
```

```{r eval=TRUE, echo=FALSE}
 #include outliers
df_mna.c$GL <- df_mna.c$GenerationLength_d
best_mna.c1 <- update(best_mna.c, data=df_mna.c)

summary(update(best_mna.c, data=df_mna.c[-which(df_mna.c$sp == "Panthera leo"),])) #exclude lion data

```

## Best-models (most parsimonious)

```{r, include=F}
# Use to calculate Confidence interval by bootstrap
getbet <- function(best_m) {
  Vcov <- vcov(best_m, useScale = FALSE)
betas <- round(fixef(best_m),3)
ci <- apply(confint(best_m, level=0.95, method="boot")[-c(1:2),],2,round,3)
cbind(betas, ci)
}
###############
```

Check results of the best-fit models

1.  Cluster dataset

```{r, echo=F}
library(broom.mixed)
res_Ho <- tidy(best_Ho, conf.int=T, conf.level=0.95, conf.method="boot")
res_Ho[,c("estimate","conf.low","conf.high")] <- sapply(res_Ho[,c("estimate","conf.low","conf.high")], round,3)
kable(res_Ho[c(1,3,4,5,2),c("term","estimate","conf.low","conf.high","p.value","df")], caption="Best-fit model Ho")
```

```{r, echo=F}
res_He <- tidy(best_He, conf.int=T, conf.level=0.95, conf.method="boot")
res_He[,c("estimate","conf.low","conf.high")] <- sapply(res_He[,c("estimate","conf.low","conf.high")], round,3)
kable(res_He[,c("term","estimate","conf.low","conf.high","p.value","df")], caption="Best-fit model He")
```

```{r, echo=F}
res_mna <- tidy(best_mna, conf.int=T, conf.level=0.95, conf.method="boot")
res_mna[,c("estimate","conf.low","conf.high")] <- sapply(res_mna[,c("estimate","conf.low","conf.high")], round,3)
kable(res_mna[,c("term","estimate","conf.low","conf.high","p.value","df")], caption="Best-fit model AR")
```

-   Country data set

```{r, echo=F}
res_Ho.c <- tidy(best_Ho.c, conf.int=T, conf.level=0.95, conf.method="boot")
res_Ho.c[,c("estimate","conf.low","conf.high")] <- sapply(res_Ho.c[,c("estimate","conf.low","conf.high")], round,3)
kable(res_Ho.c[c(1,3,4,2),c("term","estimate","conf.low","conf.high","p.value","df")], caption="Best-fit model Ho")
```

```{r, echo=F}
res_He.c <- tidy(best_He.c, conf.int=T, conf.level=0.95, conf.method="boot")
res_He.c[,c("estimate","conf.low","conf.high")] <- sapply(res_He.c[,c("estimate","conf.low","conf.high")], round,3)
kable(res_He.c[,c("term","estimate","conf.low","conf.high","p.value","df")], caption="Best-fit model He")
```

```{r, echo=F}
res_mna.c <- tidy(best_mna.c, conf.int=T, conf.level=0.95, conf.method="boot")
res_mna.c[,c("estimate","conf.low","conf.high")] <- sapply(res_mna.c[,c("estimate","conf.low","conf.high")], round,3)
kable(res_mna.c[,c("term","estimate","conf.low","conf.high","p.value","df")], caption="Best-fit model AR")
```

Compare the covariates estimates

```{r, echo=F}
library(dotwhisker)
coef_plot <- dwplot(list(best_Ho, best_He, best_mna, best_Ho.c, best_He.c, best_mna.c), ci=.95,
       show_intercept = F, margins=F, 
       vline = geom_vline(
               xintercept = 0,
               colour = "grey60",
               linetype = 2
           ))  %>%
relabel_predictors(c(
            BS_log = "Body mass",
            DP_log = "Population density",
            GL = "Generation length",
            sample.size_log = "Sample size"
        )) 



coef_plot$data$resp <- coef_plot$data$model
levels(coef_plot$data$resp) <- c("Ho","He","AR", "Ho","He","AR")
coef_plot$data$scale <- coef_plot$data$model
levels(coef_plot$data$scale) <- c(rep("Cluster",3),rep("Country",3))

dwplot(coef_plot$data, ci=0.95, model_order = c("Model 1","Model 4", "Model 2", "Model 5", "Model 3", "Model 6"),
       vline = geom_vline(
               xintercept = 0,
               colour = "grey60",
               linetype = 2
           ),
       whisker_args=list(aes(color = resp, linetype=scale), size=1),
       dot_args=list(aes(color = resp), size=2.5),
       ) + xlab("Coefficient Estimate") +
      scale_colour_grey(
        start = .1,
        end = .7,
        name = "Models",
        labels = c("Ho", "He", "AR") 
    ) +
      scale_linetype_manual(
        values=c("solid","dashed"),
        name="Dataset",
        labels=c("Cluster","Country")
    ) + guides(colour=guide_legend("Model"), 
               linetype=guide_legend("Data set"))

```

#### Model validation {.tabset}

```{r, results='asis', echo = FALSE}
plots <- function(i) { 
  hist(E, xlab="Residuals", main=paste(gd))
  plot(x=fitted(i), y=E, xlab="fitted values", ylab="residuals")
  if (any(i@frame$DP_log)) plot(i@frame$DP_log, E, xlab="Log(DP)", ylab="Residuals")
  plot(i@frame$GL, E, xlab="GL", ylab="Residuals")
  plot(i@frame$sample.size_log, E, xlab="sample size", ylab="Residuals")
}
```

```{r, results='asis', echo = FALSE}
for (j in 1:3) {
  i <- c(best_Ho, best_He, best_mna)[[j]]
  gd <- c("Ho","He","AR")[j]
  cat("##### ",gd,"\n")
  E <- resid(i)
  par(mfrow = c(2, 3), mar = c(4, 4, 3, 2))
  plots(i)
  
  cat(' \n \n')
}
```
